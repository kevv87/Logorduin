%package Tests.Jacc
%class Parser
%interface ParserTokens

%semantic Object
%get lexer.getCurrentToken()
%next lexer.getNextToken()

%{
import Compiler.Lex.Lexer;
import java.io.*;
import Logic.MessageType;
import Logic.jsonAction;
import java.util.ArrayList;
import java.util.Random;
import java.util.HashMap;
import java.util.Stack;

import Compiler.Helpers.VariableHandler;
import Compiler.Helpers.ProcedureHandler;
import Compiler.Helpers.NumberType;
%}

//Operadores y otros.
%token '+' '-' '*' '/' '(' ')' '[' ']' '<' '>' ';' '='
%token <Integer> INTEGER
%token <String> IDENTIFIER VAR INIC PARA FIN PROCEDURE_NAME PARAMETER
%token <Float> FLOAT

//Colores permitidos
%token <String> BLANCO AZUL MARRON CIAN GRIS AMARILLO NEGRO ROJO VERDE

//Procedimientos sin parámetros.
%token <String> OCULTATORTUGA OT APARECETORTUGA AT RUMBO BAJALAPIZ BL SUBELAPIZ SB CENTRO BORRAPANTALLA

//Procedimientos con un parámetro.
%token <String> AVANZA AV RETROCEDE RE GIRADERECHA GD GIRAIZQUIERDA GI PONRUMBO PONX PONY PONCOLORLAPIZ PONCL ESPERA REDONDEA COS AZAR MENOS RAIZCUADRADA RC SENO SEN

//Procedimientos con 2 parámetros.
%token <String> PONXY IGUALES Y O MAYORQUE MENORQUE POTENCIA DIVISION RESTO

//Procedimientos con N parámetros.
%token <String> DIFERENCIA PRODUCTO SUMA

//Procedimientos con paréntesis []
%token <String> INC PONPOS EJECUTA ELEGIR CUENTA ULTIMO UL PRIMERO

//Procedimientos con un parámetro y paréntesis []
%token <String> REPITE SI ELEMENTO

%left '+' '-'
%left '*' '/'

%type <Integer> int_number int_arithmetic_expr int_proc1 int_proc2 int_proc_p int_proc_1p int_proc_n
%type <Float> float_number float_arithmetic_expr float_proc float_proc1 float_proc2 float_proc_p float_proc_1p float_proc_n
%type <Boolean> logic_expr bool_proc2
%type <String> color

%%
progl: 
    prog { parseFinished(); }
    ;

//Símbolo inicial
prog
    : expression ';' prog {if($1 instanceof ArrayList){
                                                 acciones.addAll((ArrayList<jsonAction>)$1);
                                             }else if($1 instanceof jsonAction){
                                                 acciones.add((jsonAction)$1);
                                             }
                                            }
    | expression ';' {if($1 instanceof ArrayList){
                       acciones.addAll((ArrayList<jsonAction>)$1);
                   }else if($1 instanceof jsonAction){
                       acciones.add((jsonAction)$1);
                   }
                  }
    ;

//Definición de expresión
expression
    : declaration_expr
    | redeclaration_expr
    | logic_expr
    | int_arithmetic_expr
    | float_arithmetic_expr
    | int_proc1
    | int_proc2
    | int_proc_p
    | int_proc_1p
    | int_proc_n
    | float_proc
    | float_proc1
    | float_proc2
    | float_proc_p
    | float_proc_1p
    | float_proc_n
    | bool_proc2
    | void_proc{if(!($1 instanceof ArrayList)){ArrayList<jsonAction> result = new ArrayList<jsonAction>();result.add((jsonAction)$1);$$=result;}}
    | void_proc1 {if(!($1 instanceof ArrayList)){ArrayList<jsonAction> result = new ArrayList<jsonAction>();result.add((jsonAction)$1);$$=result;}}
    | void_proc2 {if(!($1 instanceof ArrayList)){ArrayList<jsonAction> result = new ArrayList<jsonAction>();result.add((jsonAction)$1);$$=result;}}
    | void_proc_p {if(!($1 instanceof ArrayList)){ArrayList<jsonAction> result = new ArrayList<jsonAction>();result.add((jsonAction)$1);$$=result;}}
    | void_proc_1p {if(!($1 instanceof ArrayList)){ArrayList<jsonAction> result = new ArrayList<jsonAction>();result.add((jsonAction)$1);$$=result;}}
    | user_procedure
    ;

//Parametros que recibe un procedimiento
parameters
    : PARAMETER parameters { procParameters.add($1); }
    | PARAMETER            { procParameters.add($1); }
    ;

instructions
    : expression instructions { procInstructions.add((String)$1); }  // TODO: Modificar a jsonAction
    | expression              { procInstructions.add((String)$1); }
    ;

//Procedimientos declarados por el usuario
user_procedure
    : user_procedure_head instructions FIN { 
        procHandler.add(varHandler.getScope(), procInstructions);
        varHandler.resetScope();
        procInstructions.clear(); }
    | user_procedure_head parameters instructions FIN { 
        procHandler.add(varHandler.getScope(), procParameters, procInstructions);
        varHandler.resetScope();
        procParameters.clear();
        procInstructions.clear(); }
    ;

//Parte inicial de la declaración del procedimiento
user_procedure_head
    : PARA PROCEDURE_NAME { varHandler.setScope($2); }
    ;

//Lo que se evalúa a un número
int_number
    : INTEGER {$$ = $1;}
    | IDENTIFIER          {$$=(Integer)varHandler.getInt($1);}
    | int_arithmetic_expr
    | int_proc1
    | int_proc2
    | int_proc_p
    | int_proc_1p
    | int_proc_n
    ;

float_number
    : FLOAT {$$=$1;}
    | IDENTIFIER            { $$=(Float)varHandler.getFloat($1); }
    | float_arithmetic_expr
    | float_proc
    | float_proc1
    | float_proc2
    | float_proc_p
    | float_proc_1p
    | float_proc_n
    ;

//Expresión para redeclarar una variable
redeclaration_expr
    : INIC IDENTIFIER '=' int_number   { if(!varHandler.isIgnore()){varHandler.modify($2,$4);} }
    | INIC IDENTIFIER '=' float_number { if(!varHandler.isIgnore()){varHandler.modify($2,$4);} }
    ;

// TODO: Las variables tienen scope global
//Expresiones para declarar una variable
declaration_expr
    : VAR IDENTIFIER                  {if(!varHandler.isIgnore()){varHandler.add($2);}}
    | VAR IDENTIFIER '=' int_number   {if(!varHandler.isIgnore()){varHandler.add($2,$4);}}
    | VAR IDENTIFIER '=' float_number {if(!varHandler.isignore()){varHandler.add($2,$4);}}
    ;

//Expresiones con valor booleano
logic_expr
    : int_number   '<' int_number    { $$ = $1 < $3; }
    | float_number '<' int_number    { $$ = $1 < $3; }
    | int_number   '<' float_number  { $$ = $1 < $3; }
    | float_number '<' float_number  { $$ = $1 < $3; }
    | int_number   '>' int_number    { $$ = $1 > $3; }
    | float_number '>' int_number    { $$ = $1 > $3; }
    | int_number   '>' float_number  { $$ = $1 > $3; }
    | float_number '>' float_number  { $$ = $1 > $3; }
    | bool_proc2 {$$ = $1;}
    ;

//Expresiones aritméticas con valor numérico
int_arithmetic_expr
    : int_number '+' int_number   { $$ = $1 + $3; }
    | int_number '-' int_number   { $$ = $1 - $3; }
    | int_number '*' int_number   { $$ = $1 * $3; }
    | '(' int_arithmetic_expr ')' { $$ = $2; }
    ;

float_arithmetic_expr
    : float_number '+' int_number   { $$ = $1 + $3; }
    | int_number   '+' float_number { $$ = $1 + $3; }
    | float_number '+' float_number { $$ = $1 + $3; }
    | float_number '-' int_number   { $$ = $1 - $3; }
    | int_number   '-' float_number { $$ = $1 - $3; }
    | float_number '-' float_number { $$ = $1 - $3; }
    | float_number '*' int_number   { $$ = $1 * $3; }
    | int_number   '*' float_number { $$ = $1 * $3; }
    | float_number '*' float_number { $$ = $1 * $3; }
    | int_number   '/' int_number   { $$ = $1 / $3; }
    | float_number '/' int_number   { $$ = $1 / $3; }
    | int_number   '/' float_number { $$ = $1 / $3; }
    | float_number '/' float_number { $$ = $1 / $3; }
    | '(' float_arithmetic_expr ')' { $$ = $2; }
    ;

//Colores permitidos
color
    : BLANCO {$$="blanco";}
    | AZUL{$$="azul";}
    | MARRON{$$="marron";}
    | CIAN{$$="cian";}
    | GRIS{$$="gris";}
    | AMARILLO{$$="amarillo";}
    | NEGRO{$$="negro";}
    | ROJO{$$="rojo";}
    | VERDE{$$="verde";}
    ;
//Procedimientos sin parámetros que devuelven un valor numérico
float_proc
    : RUMBO {$$=varHandler.getInt("rumbo");}
    ;

//Procedimientos sin parámetros ni valor de retorno
void_proc
    : OCULTATORTUGA {if(varHandler.isIgnore()){$$ =new jsonAction("ocultatortuga",1,null);}else{$$=null;}}
    | OT{if(varHandler.isIgnore()){$$ = new jsonAction("ocultatortuga",1,null);}else{$$=null;}}
    | APARECETORTUGA{if(varHandler.isIgnore()){$$ = new jsonAction("aparecetortuga",1,null);}else{$$=null;}}
    | AT{if(varHandler.isIgnore()){$$ = new jsonAction("aparecetortuga",1,null);}else{$$=null;}}
    | BAJALAPIZ{if(varHandler.isIgnore()){$$ = new jsonAction("bajalapiz",1,null);}else{$$=null;}}
    | BL{if(varHandler.isIgnore()){$$ = new jsonAction("bajalapiz",1,null);}else{$$=null;}}
    | SUBELAPIZ{if(varHandler.isIgnore()){$$ = new jsonAction("subelapiz",1,null);}else{$$=null;}}
    | SB{if(varHandler.isIgnore()){$$ = new jsonAction("subelapiz",1,null);}else{$$=null;}}
    | CENTRO{if(varHandler.isIgnore()){$$ = new jsonAction("centro",1,null);}else{$$=null;}}
    | BORRAPANTALLA{if(varHandler.isIgnore()){$$ = new jsonAction("borrapantalla",1,null);}else{$$=null;}}
    ;

//Procedimientos con un parámetro que devuelven un valor numérico
int_proc1
    : REDONDEA float_number { $$ = Math.rint($2); }
    | AZAR int_number       { Random ran = new Random(); $$ = ran.nextInt($2); }
    | MENOS int_number      { $$ = $2 * -1; }
    ;

float_proc1
    : COS int_number            { $$ = Math.cos($2); }
    | COS float_number          { $$ = Math.cos($2); }
    | MENOS float_number        { $$ = $2 * -1; }
    | RAIZCUADRADA int_number   { $$ = Math.sqrt($2); }
    | RAIZCUADRADA float_number { $$ = Math.sqrt($2); }
    | RC int_number             { $$ = Math.sqrt($2); }
    | RC float_number           { $$ = Math.sqrt($2); }
    | SENO int_number           { $$ = Math.sin($2); }
    | SENO float_number         { $$ = Math.sin($2); }
    | SEN int_number            { $$ = Math.sin($2); }
    | SEN float_number          { $$ = Math.sin($2); }
    ;

//Procedimientos con un parámetro que no tienen valor de retorno
void_proc1
    : AVANZA        int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("avanza",1,(ArrayList<Object>)argumentos);}
    | AV            int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("avanza",1,(ArrayList<Object>)argumentos);}
    | RETROCEDE     int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("retrocede",1,(ArrayList<Object>)argumentos);}
    | RE            int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("retrocede",1,(ArrayList<Object>)argumentos);}
    | GIRADERECHA   int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("giraderecha",1,(ArrayList<Object>)argumentos);}
    | GIRADERECHA   float_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                  argumentos.add($2);
                                  $$ = new jsonAction("giraderecha",1,(ArrayList<Object>)argumentos);}
    | GD            int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("giraderecha",1,(ArrayList<Object>)argumentos);}
    | GD            float_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                  argumentos.add($2);
                                  $$ = new jsonAction("giraderecha",1,(ArrayList<Object>)argumentos);}
    | GIRAIZQUIERDA int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("giraizquierda",1,(ArrayList<Object>)argumentos);}
    | GIRAIZQUIERDA float_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                  argumentos.add($2);
                                  $$ = new jsonAction("giraizquierda",1,(ArrayList<Object>)argumentos);}
    | GI            int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("giraizquierda",1,(ArrayList<Object>)argumentos);}
    | GI            float_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                  argumentos.add($2);
                                  $$ = new jsonAction("giraizquierda",1,(ArrayList<Object>)argumentos);}
    | PONRUMBO      int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("ponrumbo",1,(ArrayList<Object>)argumentos);
                                variables.replace("rumbo",(Integer)$2);}
    | PONRUMBO      float_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                  argumentos.add($2);
                                  $$ = new jsonAction("ponrumbo",1,(ArrayList<Object>)argumentos);
                                  variables.replace("rumbo",$2);}
    | PONX          int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("ponx",1,(ArrayList<Object>)argumentos);
                                variables.replace("x",(Integer)$2);}
    | PONY          int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("ponx",1,(ArrayList<Object>)argumentos);
                                variables.replace("y",$2);}
    | PONCOLORLAPIZ color {ArrayList<Object> argumentos = new ArrayList<Object>();
                           argumentos.add($2);
                           $$ = new jsonAction("poncolorlapiz",1,(ArrayList<Object>)argumentos);
                           variables.replace("colorlapiz",$2);}
    | PONCL         color {ArrayList<Object> argumentos = new ArrayList<Object>();
                           argumentos.add($2);
                           $$ = new jsonAction("poncolorlapiz",1,(ArrayList<Object>)argumentos);
                           variables.replace("colorlapiz",$2);}
    | ESPERA        int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                argumentos.add($2);
                                $$ = new jsonAction("espera",1,(ArrayList<Object>)argumentos);}
    | ESPERA        float_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                  argumentos.add($2);
                                  $$ = new jsonAction("espera",1,(ArrayList<Object>)argumentos);}
    ;

//Procedimientos con 2 parámetros que devuelven un valor numérico
int_proc2
    : POTENCIA int_number int_number { $$ = Math.pow($2, $3); }
    | RESTO    int_number int_number { $$ = $2 % $3; }
    ;

float_proc2
    : POTENCIA float_number int_number   { $$ = Math.pow($2, $3); }
    | POTENCIA int_number   float_number { $$ = Math.pow($2, $3); }
    | POTENCIA float_number float_number { $$ = Math.pow($2, $3); }
    | DIVISION int_number   int_number   { $$ = $2 / $3; }
    | DIVISION float_number int_number   { $$ = $2 / $3; }
    | DIVISION int_number   float_number { $$ = $2 / $3; }
    | DIVISION float_number float_number { $$ = $2 / $3; }
    ;

//Procedimientos con 2 parámetros que devuelven un valor booleano
bool_proc2
    : IGUALES  int_number   int_number   { $$ = $2.equals($3); }
    | IGUALES  float_number int_number   { $$ = $2.equals($3); }
    | IGUALES  int_number   float_number { $$ = $2.equals($3); }
    | IGUALES  float_number float_number { $$ = $2.equals($3); }
    | Y        logic_expr   logic_expr   { $$ = $2 && $3; }
    | O        logic_expr   logic_expr   { $$ = $2 || $3; }
    | MAYORQUE int_number   int_number   { $$ = $2 > $3; }
    | MAYORQUE float_number int_number   { $$ = $2 > $3; }
    | MAYORQUE int_number   float_number { $$ = $2 > $3; }
    | MAYORQUE float_number float_number { $$ = $2 > $3; }
    | MENORQUE int_number   int_number   { $$ = $2 < $3; }
    | MENORQUE float_number int_number   { $$ = $2 < $3; }
    | MENORQUE int_number   float_number { $$ = $2 < $3; }
    | MENORQUE float_number float_number { $$ = $2 < $3; }
    ;

//Procedimientos con 2 parámetros que no tienen valor de retorno
void_proc2
    : PONXY int_number int_number {ArrayList<Object> argumentos = new ArrayList<Object>();
                                   argumentos.add($2);
                                   argumentos.add($3);
                                   $$ = new jsonAction("ponxy",1,(ArrayList<Object>)argumentos);
                                   //TODO: Cambiar estas variables globales de ser posible
                                   variables.replace("x",$2);
                                   variables.replace("y",$3);}
    ;

//Regla para N cantidad de parámetros
// Guardar el procedimiento en un string y borrarlo al ejecutar el procedimiento.
int_params_n
    : int_number int_params_n {n_params.peek().add($1);}
    | int_number {n_params.push(new ArrayList<Object>());n_params.peek().add($1);}
    ;

float_params_n
    : float_number float_params_n {n_params.peek().add($1);}
    | float_number {n_params.push(new ArrayList<Object>());n_params.peek().add($1);}
    ;

//Procedimientos con N parámetros que devuelven un valor numérico
int_proc_n
    : DIFERENCIA int_params_n {$$=(Integer)proc_diferencia_int();n_params.pop();}
    | PRODUCTO   int_params_n {$$=(Integer)proc_producto_int();n_params.pop();}
    | SUMA       int_params_n {$$=(Integer)proc_suma_int();n_params.pop();}
    ;

float_proc_n
    : DIFERENCIA float_params_n{$$=(Float)proc_diferencia_Float();n_params.pop();}
    | PRODUCTO   float_params_n{$$=(Float)proc_producto_Float();n_params.pop();}
    | SUMA       float_params_n{$$=(Float)proc_suma_Float();n_params.pop();}
    ;

//Regla para definir cualquier cantidad de órdenes
expr_procs_n
    : expression expr_procs_n
    | expression   // Crea una nueva lista de quaseacciones y le agrega la produccion.
    ;

//Procedimientos con paréntesis que devuelven un valor numérico
int_proc_p
    : ELEGIR  '[' int_params_n   ']'  {$$ = elegir_int();n_params.pop();}
    | CUENTA  '[' int_params_n   ']'{$$ = cuenta();n_params.pop();}
    | CUENTA  '[' float_params_n ']'{$$ = cuenta();n_params.pop();}
    | ULTIMO  '[' int_params_n   ']'{$$ = ultimo_int();n_params.pop();}
    | UL      '[' int_params_n   ']'{$$ = ultimo_int();n_params.pop();}
    | PRIMERO '[' int_params_n   ']'{$$ = primero_int();n_params.pop();}
    ;

float_proc_p
    : ELEGIR  '[' float_params_n ']'{$$ = elegir_float();n_params.pop();}
    | ULTIMO  '[' float_params_n ']'{$$ = ultimo_float();n_params.pop();}
    | UL      '[' float_params_n ']'{$$ = ultimo_float();n_params.pop();}
    | PRIMERO '[' float_params_n ']'{$$ = primero_float();n_params.pop();}
    ;


//Procedimientos con paréntesis que no tienen valor de retorno
void_proc_p
    : INC     '[' IDENTIFIER              ']' {variables.replace($3, (Integer)variables.get($3)+1);}
    | INC     '[' IDENTIFIER int_number   ']' {variables.replace($3, (Integer)variables.get($3)+$4);}
    | INC     '[' IDENTIFIER float_number ']' {variables.replace($3, (Float)variables.get($3)+$4);}
    | PONPOS  '[' int_number int_number   ']' {ArrayList<Object> argumentos = new ArrayList<Object>();
                                                                                 argumentos.add($2);
                                                                                 argumentos.add($3);
                                                                                 $$ = new jsonAction("espera",1,(ArrayList<Object>)argumentos);
                                                                                 variables.replace("x",$3);
                                                                                 variables.replace("y",$4);}
    | EJECUTA '[' expr_procs_n ']' {$$=$3;} // TODO: Probar esto
    ;

// Procedimientos con parentesis y un parametro que devuelven un valor.
int_proc_1p
    : ELEMENTO int_number '[' int_params_n ']' {$$=elemento_int($2);n_params.pop();}
    ;

float_proc_1p
    : ELEMENTO int_number '[' float_params_n ']'{$$=elemento_float($2);n_params.pop();}
    ;

// Procedimientos con parentesis y un parametro que no devuelven un valor.
// TODO: No agregar las acciones json de una vez al json, agregarlas aparte y luego hacer la verificacion de si se tienen que agregar o no.
// TODO: Esto puede ayudar de una vez a guardar en el Hashmap los procedimientos especificados por el usuario.
void_proc_1p
    : proc_head '[' expr_procs_n ']' {varHandler.resetScope();}  //TODO: Quaseaccion se vuelve accion con n repeticiones
    ;

proc_head
    : REPITE int_number { varHandler.setScope("repite");}
    | SI logic_expr     {if(!((boolean)$2)){varHandler.setScope("ignore");}}
    ;

%%

    public Lexer lexer;
    
    public VariableHandler varHandler;
    public ProcedureHandler procHandler;
    public ArrayList<String> procParameters; //Para almacenar parámetros de un procedimiento temporalmente
    public ArrayList<String> procInstructions; //Para almacenar instrucciones de un procedimineto temporalmente

	private ArrayList<jsonAction> acciones; // Aqui se guardan las acciones definitivas a ejecutar en la interfaz, TODO: Guardar una version en texto plano de este array list en un documento
	private Stack<ArrayList<jsonAction>> quaseAcciones; // Aqui se guardan las acciones que el compilador tiene por definir si se van a agregar al codigo de maquina
	private HashMap<String, Object> variables; // Aqui se guardan las variables en tiempo de compilacion

	// Variables para la ejecucion de procedimientos con n params
	private Stack<ArrayList<Object>> n_params; // Aqui se guardan los parametros de los procedimientos que tienen multiples parametros
	private String proc; // Procedimiento a ejecutar

    public void yyerror(String msg) {
        int lastToken = lexer.getCurrentToken(); //Para verificar si se llegó al final de línea.
        if (lastToken == 0) {
            parseFinished();
            return;
        }

        System.out.println(msg);
        System.out.println("En " + lexer.getSemantic() + ", línea " + (lexer.getCurrentLine() + 1) + ". columna " + (lexer.getCurrentColumn() + 1));
    }

    public Parser(String ruta) {
        quaseAcciones = new Stack<ArrayList<jsonAction>>();
	    acciones = new ArrayList<jsonAction>();
	    variables = new HashMap<String, Object>();
	    n_params = new Stack<ArrayList<Object>>();

        varHandler = new VariableHandler();
        procHandler = new ProcedureHandler();
        procParameters = new ArrayList<>();
        procInstructions = new ArrayList<>();

	    // Inicializacion de variables predefinidas
	    variables.put("rumbo",new Float(0.0));
	    variables.put("colorlapiz","negro");
	    variables.put("x",300.0);
	    variables.put("y",300.0);
        try {
            Reader reader = new BufferedReader(new FileReader(ruta));
            lexer = new Lexer(reader);
            lexer.getNextToken();
        } catch (IOException ex) {
            yyerror("Could not open file for parsing.");
        }
    }

    /**
    * Metodo que representa el procedimiento elemento
    * @return El elemento en la posicion n-esima de los parametros.
     */
    private Integer elemento_int(Integer n){
        return (Integer)n_params.peek().get(n);
    }

    private Float elemento_float(Integer n){
        return (Float)n_params.peek().get(n);
    }

    /**
    * Metodo que representa el proceso de suma con n parametros
    * @return La suma de los n parametros.
    */
    private Float proc_suma_Float(){
        if(n_params.peek().size()==0){
            return new Float(0.0);
        }else{
            return (Float)n_params.peek().remove(n_params.peek().size()-1) + proc_suma_Float();
        }
    }
    private Integer proc_suma_int(){
            if(n_params.peek().size()==0){
                return 0;
            }else{
                return (Integer)n_params.peek().remove(n_params.peek().size()-1) + proc_suma_int();
            }
        }
    /**
        * Metodo que representa el proceso de producto con n parametros
        * @return La suma de los n parametros.
        */
        private Float proc_diferencia_Float(){
            Float resultado = (Float)n_params.peek().get(n_params.peek().size()-1);
            for(int i=n_params.peek().size()-2;i>=0;i--){
                resultado -= (Float)n_params.peek().get(i);
            }
            return resultado;
        }
        private Integer proc_diferencia_int(){
                    Integer resultado = (Integer)n_params.peek().get(n_params.peek().size()-1);
                    for(int i=n_params.peek().size()-2;i>=0;i--){
                        resultado -= (Integer)n_params.peek().get(i);
                    }
                    return resultado;
                }
        /**
        * Metodo que representa el proceso de producto con n parametros
        * @return La suma de los n parametros.
        */
        private Float proc_producto_Float(){
            if(n_params.peek().size()==0){
                return new Float(1.0);
            }else{
                return (Float)n_params.peek().remove(n_params.peek().size()-1) * proc_producto_Float();
            }
        }
        private Integer proc_producto_int(){
            if(n_params.peek().size()==0){
                return 1;
            }else{
                return (Integer)n_params.peek().remove(n_params.peek().size()-1) * proc_producto_int();
            }
        }

    /**
     * Metodo que representa el procedimiento elegir.
     * @return Un numero al azar entre los numeros en los parametros.
     */
    private Integer elegir_int(){
        return (Integer)n_params.peek().get(new Random().nextInt(n_params.peek().size()));
    }

    private Float elegir_float(){
        return (Float)n_params.peek().get(new Random().nextInt(n_params.peek().size()));
    }

    /**
    * Metodo que representa el procedimiento cuenta
    * @return Numero de parametros
    */
    private Integer cuenta(){
        return n_params.peek().size();
    }

    /**
    * Metodo que representa el procedimiento ultimo.
    * @return Retorna el ultimo elemento de los parametros.
     */
    private Integer ultimo_int(){
        return (Integer)n_params.peek().get(0);
    }

    private Float ultimo_float(){
        return (Float)n_params.peek().get(0);
    }

    /**
    * Metodo que representa el procedimiento primero.
    * @return El primero de los parametros.
     */
    private Integer primero_int(){
        return (Integer) n_params.peek().get(n_params.peek().size()-1);
    }

    private Float primero_float(){
        return (Float) n_params.peek().get(n_params.peek().size()-1);
    }

    /**
     * Función para mostrar un mensaje del compilador en la interfaz.
     */
    public void showMessage(String msg, MessageType type) {
        //TODO: mostrar mensaje del tipo correspondiente en la interfaz.
    }

    public void parseFinished() {
        System.out.println("Compilación finalizada correctamente.");
        //TODO: notificar interfaz que finalizó la compilación.

        //TEST
        varHandler.printVars();
        procHandler.printProcedures();
    }

    public static void main(String[] args) {
        //TODO: recibir ruta desde args.
        String path = "/src/Compiler/Lex/parse.txt";
        String ruta  = System.getProperty("user.dir").replaceAll("\\\\", "/") + path;
        Parser parser = new Parser(ruta);
        parser.parse();
    }